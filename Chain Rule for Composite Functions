import numpy as np

def compute_chain_rule_gradient(functions: list[str], x: float) -> float:
	"""
	Compute derivative of composite functions using chain rule.
	
	Args:
		functions: List of function names (applied right to left)
		          Available: 'square', 'sin', 'exp', 'log'
		x: Point at which to evaluate derivative
	
	Returns:
		Derivative value at x
	
	Example:
		['sin', 'square'] represents sin(x²)
		['exp', 'sin', 'square'] represents exp(sin(x²))
	"""

    value = x
    derivative = 1.0

    for fn in reversed(functions):
        if fn == 'square':
            derivative *= 2 * value
            value = value ** 2

        elif fn == 'sin':
            derivative *= np.cos(value)
            value = np.sin(value)

        elif fn == 'exp':
            derivative *= np.exp(value)
            value = np.exp(value)

        elif fn == 'log':
            derivative *= 1 / value
            value = np.log(value)

        else:
            raise ValueError(f"Unsupported function: {fn}")

    return round(float(derivative), 6)
