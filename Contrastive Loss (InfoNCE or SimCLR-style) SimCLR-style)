import numpy as np

def contrastive_loss(embeddings: np.ndarray, temperature: float) -> float:
    """
    Compute the NT-Xent (SimCLR-style) contrastive loss.
    
    Args:
        embeddings: Array of shape (2N, d) where consecutive pairs
                    (2i, 2i+1) are positive pairs.
        temperature: Temperature scaling parameter (tau > 0).
    
    Returns:
        The mean contrastive loss as a float.
    """

    n = embeddings.shape[0]  
    
    norms = np.linalg.norm(embeddings, axis=1, keepdims=True)
    normalized = embeddings / norms
    
    sim_matrix = normalized @ normalized.T
    
    sim_matrix = sim_matrix / temperature
    
    np.fill_diagonal(sim_matrix, -np.inf)
    
    positives = np.array([
        i + 1 if i % 2 == 0 else i - 1
        for i in range(n)
    ])
    
    losses = []
    
    for i in range(n):
        logits = sim_matrix[i]
        
        max_logit = np.max(logits)
        log_sum_exp = max_logit + np.log(
            np.sum(np.exp(logits - max_logit))
        )
        
        loss_i = -sim_matrix[i, positives[i]] + log_sum_exp
        losses.append(loss_i)
    
    return float(np.mean(losses))
    pass
